'''Script to create the initial setup for a new project'''

import sys, os, subprocess

class Project(object):
    '''A class to handle the setup of a new project'''
    project_name = ""
    project_full_path = ""
    project_build_full_path = ""
    cmake_command = ['cmake', "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON", "-GNinja"]

    def __init__(self):
        pass

    def init(self):
        '''Ask and setup the configuration'''

        if len(sys.argv) < 2:
            print("Please set a project name as argument.", "")
            return False
        else:
            self.project_name = sys.argv[1]
            print("Name of the project:", self.project_name)

            self.project_full_path = os.path.join(os.path.expanduser("~"),
                    "projects", self.project_name)
            print("Project full path:", self.project_full_path)

            self.project_build_full_path = os.path.join(self.project_full_path,
                    "build")
            print("Project build full path:", self.project_build_full_path)
            return True

    def build_ycm_configuration_file(self):
        '''Build the configuration file for YCM'''

        ycm_configuration = """'''Configuration for YCM'''
import os
import ycm_core

# Set this to the absolute path to the folder (NOT the file!) containing the
# compile_commands.json file to use that instead of 'flags'. See here for
# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
compilation_database_folder = \"""" + self.project_build_full_path + """\"

if os.path.exists( compilation_database_folder ):
  database = ycm_core.CompilationDatabase( compilation_database_folder )
else:
  database = None

SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]

def DirectoryOfThisScript():
  return os.path.dirname( os.path.abspath( __file__ ) )


def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
  if not working_directory:
    return list( flags )
  new_flags = []
  make_next_absolute = False
  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
  for flag in flags:
    new_flag = flag

    if make_next_absolute:
      make_next_absolute = False
      if not flag.startswith( '/' ):
        new_flag = os.path.join( working_directory, flag )

    for path_flag in path_flags:
      if flag == path_flag:
        make_next_absolute = True
        break

      if flag.startswith( path_flag ):
        path = flag[ len( path_flag ): ]
        new_flag = path_flag + os.path.join( working_directory, path )
        break

    if new_flag:
      new_flags.append( new_flag )
  return new_flags


def IsHeaderFile( filename ):
  extension = os.path.splitext( filename )[ 1 ]
  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]


def GetCompilationInfoForFile( filename ):
  # The compilation_commands.json file generated by CMake does not have entries
  # for header files. So we do our best by asking the db for flags for a
  # corresponding source file, if any. If one exists, the flags for that file
  # should be good enough.
  if IsHeaderFile( filename ):
    basename = os.path.splitext( filename )[ 0 ]
    for extension in SOURCE_EXTENSIONS:
      replacement_file = basename + extension
      if os.path.exists( replacement_file ):
        compilation_info = database.GetCompilationInfoForFile(
          replacement_file )
        if compilation_info.compiler_flags_:
          return compilation_info
    return None
  return database.GetCompilationInfoForFile( filename )


def FlagsForFile( filename, **kwargs ):
  if database:
    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
    # python list, but a "list-like" StringVec object
    compilation_info = GetCompilationInfoForFile( filename )
    if not compilation_info:
      return None

    final_flags = MakeRelativePathsInFlagsAbsolute(
      compilation_info.compiler_flags_,
      compilation_info.compiler_working_dir_ )

    # NOTE: This is just for YouCompleteMe; it's highly likely that your project
    # does NOT need to remove the stdlib flag. DO NOT USE THIS IN YOUR
    # ycm_extra_conf IF YOU'RE NOT 100% SURE YOU NEED IT.
    try:
      final_flags.remove( '-stdlib=libc++' )
    except ValueError:
      pass
  else:
    relative_to = DirectoryOfThisScript()
    final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )

  return {
    'flags': final_flags,
    'do_cache': True
  }
"""
        a_file = open(os.path.join(self.project_full_path,
            ".ycm_extra_conf.py"), "w")
        a_file.write(ycm_configuration)
        a_file.close()

    def build_cmake_configuration_file(self):
        '''Build the configuration for cmake'''

        cmake_configuration = """PROJECT( """ + self.project_name + """ )
CMAKE_MINIMUM_REQUIRED( VERSION 2.8.11)
SET( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Wextra -pedantic -g3 -ggdb3")

#SET( CMAKE_MODULE_PATH  "${CMAKE_CURRENT_SOURCE_DIR}/modules/")
#FIND_PACKAGE( GLM REQUIRED)
#FIND_PACKAGE( Bullet REQUIRED)
#FIND_PACKAGE()
#FIND_PACKAGE( Qt5Gui REQUIRED)
#FIND_PACKAGE( Qt5Quick REQUIRED)
#FIND_PACKAGE( Qt5Widgets REQUIRED)
        
#FIND_PACKAGE( PkgConfig)
#PKG_CHECK_MODULES(SDL2 REQUIRED sdl2)
#PKG_CHECK_MODULES(SDL2_Image REQUIRED SDL2_image)
#PKG_CHECK_MODULES(SDL2_ttf REQUIRED SDL2_ttf)

#INCLUDE_DIRECTORIES( ${SDL2_INCLUDE_DIRS})
#INCLUDE_DIRECTORIES( ${SDL2_Image_INCLUDE_DIRS})
#INCLUDE_DIRECTORIES( ${SDL2_ttf__INCLUDE_DIRS})
#INCLUDE_DIRECTORIES( ${GLM_INCLUDE_DIRS})
#INCLUDE_DIRECTORIES( ${BULLET_INCLUDE_DIRS})

SET( SOURCE_FILES
    main.cpp
)

#INCLUDE_DIRECTORIES( include)
#SET( HEADER_FILES
#   include/
#)

ADD_EXECUTABLE( """ + self.project_name + """ ${SOURCE_FILES})
#TARGET_LINK_LIBRARIES( """ + self.project_name + """
#        ${SDL2_LIBRARIES} 
#        ${SDL2_Image_LIBRARIES}
#        ${SDL2_ttf_LIBRARIES}
#        ${BULLET_LIBRARIES}
#        Qt5::Gui Qt5::Quick Qt5::Widgets
#)

#ADD_SUBDIRECTORY(images)
#ADD_SUBDIRECTORY(font)
"""
        a_file = open(os.path.join(self.project_full_path, "CMakeLists.txt"),
                "w")
        a_file.write(cmake_configuration)
        a_file.close()

    def build_main_cpp_file(self):
        '''Create a simple main.cpp startup file'''

        main_cpp = """#include <iostream>

int main(){
    return 0;
}
"""
        a_file = open(os.path.join(self.project_full_path, "main.cpp"), "w")
        a_file.write(main_cpp)
        a_file.close()

    def build_hg_ignore_file(self):
        '''Build a .hgignore file'''

        hg_ignore = """syntax:glob
build/
.ycm_extra_conf.py
default.vim*
*swp
*~
"""
        a_file = open(os.path.join(self.project_full_path, ".hgignore"), "w")
        a_file.write(hg_ignore)
        a_file.close()

    def run_commands(self):
        '''Run commands, e.g. hg, cmake, ninja'''

        print("Running:", "hg init")
        subprocess.check_output(["hg", "init"], cwd=self.project_full_path)

        print("Running:", "hg add")
        subprocess.check_output(["hg", "add"], cwd=self.project_full_path)

        print("Running:", "hg ci -m \"Initial Commit.\"")
        subprocess.check_output(["hg", "ci", "-m \"Initial Commit.\""],
                cwd=self.project_full_path)

        self.cmake_command.append(self.project_full_path)
        print("Running:", self.cmake_command)
        subprocess.check_output(self.cmake_command,
                cwd=self.project_build_full_path)

        print("Running:", "ninja")
        subprocess.check_output(["ninja"], cwd=self.project_build_full_path)

    def create(self):
        '''Use setup and create files'''

        if os.path.exists(self.project_full_path):
            print("Project \"" + self.project_name + "\" already exists. Doing "
            "nothing.")
            return False
        else:
            os.makedirs(self.project_full_path)
            os.makedirs(self.project_build_full_path)
            self.build_ycm_configuration_file()
            self.build_cmake_configuration_file()
            self.build_main_cpp_file()
            self.build_hg_ignore_file()
            self.run_commands()
            print("Setting up", self.project_name, ": Done.")
            return True


if __name__ == "__main__":
    PROJECT = Project()
    if PROJECT.init():
        PROJECT.create()


